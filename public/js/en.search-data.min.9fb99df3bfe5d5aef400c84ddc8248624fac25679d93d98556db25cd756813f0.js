'use strict';(function(){const indexCfg={};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create(indexCfg);window.geekdocSearchIndex=index;index.add({'id':0,'href':'ele38.github.io/main/','title':"Main",'content':"Table of Contents  Estructuras lineales  Vectores  Asignar un valor push back (empujar atr√°s) pop back (quitar atr√°s) insert (insertar) erase (borrar)   Stacks (pilas)  push (empujar) top (cima) pop (quitar) empty (vac√≠o) size (tama√±o)   Queues (colas)  push (empujar) front (frente) pop (quitar) empty (vac√≠o) size (tama√±o)     Estructuras en forma de √°rbol  Set (conjunto)  Inicializaci√≥n insert (Insertar) find (Encontrar) erase (borrar) Iterar a trav√©s de un conjunto   Map (mapa, tabla de hashing)  Ejemplo cotidiano Inicializar Insert (insertar) Operar con los valores Find (encontrar) Erase (borrar) Recorrer los valores de un vector Dudas que no dejan dormir      \nEstructuras lineales \nVectores  Los vectores son como arreglos, excepto de que el tama√±o es din√°mico, es decir, se puede cambiar. Incluimos la librer√≠a:\n1 #include \u0026lt;vector\u0026gt;  Inicializamos nuestro vector ‚Äúvec‚Äù:\n2 int n = 3; 3 vector \u0026lt; int \u0026gt; vec(n, 0); // Inicializa un vector de tama√±o 3 con todos sus valores = 0. Tanto el tama√±o como valor son opcionales.  \nAsignar un valor 4 vec[2] = 1; // Asigna el valor \u0026quot;1\u0026quot; al √≠ndice 2 (es decir, al 3er valor del vector)  \npush back (empujar atr√°s) Si no sabemos el tama√±o de nuestro vector, podemos simplemente usar pushback(valor); para enviar es valor al final del vector.\n5 vec.push_back(1); // Inserta un 1 al final del vector  Por ejemplo, se podr√≠a usar en un for, sin necesidad de inicializar el vector con una cantidad de valores.\n 6 vector \u0026lt;int\u0026gt; vec2; 7 int n; 8 cin \u0026gt;\u0026gt; n; 9 for (int i = 0; i \u0026lt; n; ++i){ 10 int valor; 11 cin \u0026gt;\u0026gt; valor; 12 vec2.push_back(); 13 }  \npop back (quitar atr√°s) Elimina el √∫ltimo valor del vector.\n14 vec.pop_back(); // En este caso, elimina el 1  \ninsert (insertar) Podemos insertar un valor entre dos indices de un vector. El problema de esto es que mueve todos los valores que est√©n m√°s adelante, lo que es lento.\n15 vec.insert(vec.begin() + 2, 4); // Inserta el valor 4 al √≠ndice 2  \nerase (borrar) Borra un dato del vector. Al igual que el insert, tiene que mover todos los datos siguientes (esta vez a la derecha).\n16 vec.erase(vec.begin() + 2); // Elimina el valor con √≠ndice 2, en nuestro caso, el 4 que insertamos antes.  \nStacks (pilas)  La pila es una estructura de datos lineal al que s√≥lo puedes acceder al √∫ltimo elemento que fue insertado. Imagina una pila de platos, por ejemplo.\n1 stack \u0026lt; int \u0026gt; pilita;  \npush (empujar) Empuja un dato a la cima de la pila.\n2 pilita.push(8); // Empuja un 8 a la cima de la pila.  \ntop (cima) Lee lo que hay en la cima de la pila.\n3 pilita.top(); // Retorna el 8.  \npop (quitar) Remueve el dato de la cima de la pila.\n4 pilita.pop(); // Remueve el 8.  \nempty (vac√≠o) Retorna 1 si la pila est√° vac√≠a, de lo contrario retorna 0.\n5 pilita.empty(); // Retorna 1 ya que nuestra pila est√° vac√≠a.  \nsize (tama√±o) Retorna el tama√±o de nuestra pila.\n6 pilita.size(); // Retorna 0 ya que nuestra pila no tiene datos.  \nQueues (colas)  La cola es una estructura de datos lineal al que s√≥lo puedes acceder al primer elemento que fue insertado. Imagina una fila de una caja de un supermercado, por ejemplo.\n1 queue \u0026lt; int \u0026gt; colita;  \npush (empujar) A√±ade un dato al final de la cola.\n2 colita.push(5); 3 colita.push(4); 4 colita.push(3); 5 colita.push(2); 6 colita.push(1);  \nfront (frente) Lee el dato que est√° al frente de la cola.\n7 colita.front(); // Retorna 5, ya que fue lo primero que empujamos a la cola.  \npop (quitar) Remueve el dato que est√° al frente de la cola\n8 colita.pop(); // Remueve el 5 9 colita.front(); // Retorna 4, ya que fue lo segundo que empujamos a la cola (y que ahora est√° primero).  \nempty (vac√≠o) Retorna 1 si la cola est√° vac√≠a, de lo contrario retorna 0.\n10 colita.empty(); // Retorna 1 ya que nuestra cola est√° vac√≠a.  \nsize (tama√±o) Retorna el tama√±o de nuestra cola.\n11 colita.size(); // Retorna 0 ya que nuestra cola no tiene datos.  \nEstructuras en forma de √°rbol V√©ase: arbol binario\n\nSet (conjunto)  No permite que hayan elementos repetidos.\n\nInicializaci√≥n Incluimos la librer√≠a:\n1 #include \u0026lt;set\u0026gt;  Inicializamos nuestro conjunto:\n2 set \u0026lt; int \u0026gt; conjunto; // int puede ser reemplazado con cualquier otro tipo de dato  \ninsert (Insertar) Inserta un dato. Retorna un par de elementos, el primero siendo el iterador del valor insertado y el segundo siendo un bool que marca si es que ya exist√≠a o no. En el ejemplo de abajo, usamos .second para comprobar si se insert√≥ correctamente o no.\n3 if (conjunto.insert(10).second) // Retorna TRUE ya que no estaba anteriormente 4 cout \u0026lt;\u0026lt; \u0026quot;ganai\\n\u0026quot;; if (conjunto.insert(10).second); // Retorna FALSE ya que ya hab√≠a un 10. 5 cout \u0026lt;\u0026lt; \u0026quot;no ganai\\n\u0026quot;; 6 conjunto.insert(20); 7 conjunto.insert(40); 8 conjunto.insert(30); 9 conjunto.insert(11);  \nfind (Encontrar) Busca un elemento en el set y si lo encuentra retorna un iterador al valor. De lo contrario, retorna conjunto.end();\n10 if (conjunto.find(10) != conjunto.end()) 11 cout \u0026lt;\u0026lt; \u0026quot;ganai\\n\u0026quot;;  \nerase (borrar) Puedes borrar un valor si le entregas el iterador al valor.\n12 set \u0026lt; int \u0026gt;::iterator it = conjunto.find(11); 13 if (it != conjunto.end()) 14 conjunto.erase(it);  \nIterar a trav√©s de un conjunto Puedes iterar a trav√©s de un conjunto con los valores ya ordenados con un iterador:\n15 // Imprime 10 11 20 30 40 16 for (it = conjunto.begin(); it != conjunto.end(); ++it) 17 cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026quot; \u0026quot;; 18 cout \u0026lt;\u0026lt; '\\n';  \nMap (mapa, tabla de hashing)  Toma dos datos, una llave y un valor. Puedes buscar una llave en tiempo logar√≠tmico con la implementaci√≥n de la STL. Pero con otras implementaciones se puede hacer en tiempo constante. Las llaves no se pueden repetir.\n\nEjemplo cotidiano Libros:\n    T√≠tulo (Llave) Autor (Valor)     The C Programming Language Brian Keringhan   The AWK Programming Language Brian Keringhan   1984 George Orwell    Curso:\n    Apellido Cantidad de alumnos con el apellido     Gonzalez 3   Perez 2    \nInicializar Incluimos la librer√≠a de map:\n1 #include \u0026lt;map\u0026gt;  Inicializamos el mapa curso:\n2 map\u0026lt;string, int\u0026gt; curso;  \nInsert (insertar) Forma 1:\n3 curso[\u0026quot;perez\u0026quot;] = 1;  Forma 2:\n4 curso.insert(pair\u0026lt;string, int\u0026gt;(\u0026quot;gonzalez, 3\u0026quot;));  \nOperar con los valores Se puede operar con el valor tomando la llave. Ejemplo 1:\n5 ++curso.[\u0026quot;perez\u0026quot;]; // Incrementar el valor de la llave perez, por ejemplo.  Ejemplo 2:\n6 cout \u0026lt;\u0026lt; curso.[\u0026quot;perez\u0026quot;] \u0026lt;\u0026lt; endl; // El output ser√° 2.  Cuidado con operar con valores no existentes, pues los inicializar√° de una forma inesperada.\n\nFind (encontrar) Retorna un iterador, si no lo encuentra, apunta a map.end() Asignamos el iterador it a gonzalez, y luego lo usamos:\n 7 map\u0026lt;string, int\u0026gt;::iterator it; 8 it = curso.find(\u0026quot;gonzalez\u0026quot;); 9 10 if (it != curso.end()){ 11 cout \u0026lt;\u0026lt; \u0026quot;Hay \u0026quot; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026quot; en el curso:\\n\u0026quot;; 12 cout \u0026lt;\u0026lt; \u0026quot;Llave: \u0026quot; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026quot; Valor: \u0026quot; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; '\\n'; 13 }  Podemos incluso operar usando los iteradores:\n14 it-\u0026gt;++second;  \nErase (borrar) Forma 1:\n15 it = curso.find(\u0026quot;perez\u0026quot;); 16 curso.erase(it);  Forma 2:\n17 curso.erase(\u0026quot;gonzalez\u0026quot;);  \nRecorrer los valores de un vector Es exactamente igual que en un conjunto:\n18 for (it = curso.begin(); it != curso.end(); ++it){ 19 cout \u0026lt;\u0026lt; \u0026quot;Llave: \u0026quot; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026quot; Valor: \u0026quot; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; '\\n'; 20 }  \nDudas que no dejan dormir   ¬øQu√© pasa si modifico una llave?\nNo se puede, tu c√≥digo no compilar√° pues es ilegal hacerlo üëÆüöìüö®\n  ¬øPuedo buscar con el second?\nNo, en ese caso recomendamos otra estructura, o tener dos maps üëÄ\n  ¬øPuedo tener un map dentro de un map?\nSi, pero es de psic√≥pata buscar dentro de ese map.\n  "});index.add({'id':1,'href':'ele38.github.io/','title':"Apuntes YoC+",'content':""});index.add({'id':2,'href':'ele38.github.io/categories/','title':"Categories",'content':""});index.add({'id':3,'href':'ele38.github.io/clases/','title':"Clases",'content':""});index.add({'id':4,'href':'ele38.github.io/clases/main/','title':"Estructuras de datos",'content':" Table of Contents  Estructuras lineales  Vectores  Asignar un valor push back (empujar atr√°s) pop back (quitar atr√°s) insert (insertar) erase (borrar)   Stacks (pilas)  push (empujar) top (cima) pop (quitar) empty (vac√≠o) size (tama√±o)   Queues (colas)  push (empujar) front (frente) pop (quitar) empty (vac√≠o) size (tama√±o)     Estructuras en forma de √°rbol  Set (conjunto)  Inicializaci√≥n insert (Insertar) find (Encontrar) erase (borrar) Iterar a trav√©s de un conjunto   Map (mapa, tabla de hashing)  Ejemplo cotidiano Inicializar Insert (insertar) Operar con los valores Find (encontrar) Erase (borrar) Recorrer los valores de un vector Dudas que no dejan dormir        Estructuras lineales Vectores  Los vectores son como arreglos, excepto de que el tama√±o es din√°mico, es decir, se puede cambiar. Incluimos la librer√≠a:\n1  #include \u0026lt;vector\u0026gt;   Inicializamos nuestro vector \u0026ldquo;vec\u0026rdquo;:\n2 3  int n = 3; vector \u0026lt; int \u0026gt; vec(n, 0); // Inicializa un vector de tama√±o 3 con todos sus valores = 0. Tanto el tama√±o como valor son opcionales.    Asignar un valor 4  vec[2] = 1; // Asigna el valor \u0026#34;1\u0026#34; al √≠ndice 2 (es decir, al 3er valor del vector)    push back (empujar atr√°s) Si no sabemos el tama√±o de nuestro vector, podemos simplemente usar push_back(valor); para enviar es valor al final del vector.\n5  vec.push_back(1); // Inserta un 1 al final del vector    Por ejemplo, se podr√≠a usar en un for, sin necesidad de inicializar el vector con una cantidad de valores.\n6 7 8 9 10 11 12 13  vector \u0026lt;int\u0026gt; vec2; int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; ++i){ int valor; cin \u0026gt;\u0026gt; valor; vec2.push_back(); }    pop back (quitar atr√°s) Elimina el √∫ltimo valor del vector.\n14  vec.pop_back(); // En este caso, elimina el 1    insert (insertar) Podemos insertar un valor entre dos indices de un vector. El problema de esto es que mueve todos los valores que est√©n m√°s adelante, lo que es lento.\n15  vec.insert(vec.begin() + 2, 4); // Inserta el valor 4 al √≠ndice 2    erase (borrar) Borra un dato del vector. Al igual que el insert, tiene que mover todos los datos siguientes (esta vez a la derecha).\n16  vec.erase(vec.begin() + 2); // Elimina el valor con √≠ndice 2, en nuestro caso, el 4 que insertamos antes.    Stacks (pilas)  La pila es una estructura de datos lineal al que s√≥lo puedes acceder al √∫ltimo elemento que fue insertado. Imagina una pila de platos, por ejemplo.\n1  stack \u0026lt; int \u0026gt; pilita;    push (empujar) Empuja un dato a la cima de la pila.\n2  pilita.push(8); // Empuja un 8 a la cima de la pila.    top (cima) Lee lo que hay en la cima de la pila.\n3  pilita.top(); // Retorna el 8.    pop (quitar) Remueve el dato de la cima de la pila.\n4  pilita.pop(); // Remueve el 8.    empty (vac√≠o) Retorna 1 si la pila est√° vac√≠a, de lo contrario retorna 0.\n5  pilita.empty(); // Retorna 1 ya que nuestra pila est√° vac√≠a.    size (tama√±o) Retorna el tama√±o de nuestra pila.\n6  pilita.size(); // Retorna 0 ya que nuestra pila no tiene datos.    Queues (colas)  La cola es una estructura de datos lineal al que s√≥lo puedes acceder al primer elemento que fue insertado. Imagina una fila de una caja de un supermercado, por ejemplo.\n1  queue \u0026lt; int \u0026gt; colita;    push (empujar) A√±ade un dato al final de la cola.\n2 3 4 5 6  colita.push(5); colita.push(4); colita.push(3); colita.push(2); colita.push(1);    front (frente) Lee el dato que est√° al frente de la cola.\n7  colita.front(); // Retorna 5, ya que fue lo primero que empujamos a la cola.    pop (quitar) Remueve el dato que est√° al frente de la cola\n8 9  colita.pop(); // Remueve el 5 colita.front(); // Retorna 4, ya que fue lo segundo que empujamos a la cola (y que ahora est√° primero).    empty (vac√≠o) Retorna 1 si la cola est√° vac√≠a, de lo contrario retorna 0.\n10  colita.empty(); // Retorna 1 ya que nuestra cola est√° vac√≠a.    size (tama√±o) Retorna el tama√±o de nuestra cola.\n11  colita.size(); // Retorna 0 ya que nuestra cola no tiene datos.    Estructuras en forma de √°rbol V√©ase: arbol binario\nSet (conjunto)  No permite que hayan elementos repetidos.\nInicializaci√≥n Incluimos la librer√≠a:\n1  #include \u0026lt;set\u0026gt;   Inicializamos nuestro conjunto:\n2  set \u0026lt; int \u0026gt; conjunto; // int puede ser reemplazado con cualquier otro tipo de dato    insert (Insertar) Inserta un dato. Retorna un par de elementos, el primero siendo el iterador del valor insertado y el segundo siendo un bool que marca si es que ya exist√≠a o no. En el ejemplo de abajo, usamos .second para comprobar si se insert√≥ correctamente o no.\n3 4 5 6 7 8 9  if (conjunto.insert(10).second) // Retorna TRUE ya que no estaba anteriormente  cout \u0026lt;\u0026lt; \u0026#34;ganai\\n\u0026#34;; if (conjunto.insert(10).second); // Retorna FALSE ya que ya hab√≠a un 10. cout \u0026lt;\u0026lt; \u0026#34;no ganai\\n\u0026#34;; conjunto.insert(20); conjunto.insert(40); conjunto.insert(30); conjunto.insert(11);    find (Encontrar) Busca un elemento en el set y si lo encuentra retorna un iterador al valor. De lo contrario, retorna conjunto.end();\n10 11  if (conjunto.find(10) != conjunto.end()) cout \u0026lt;\u0026lt; \u0026#34;ganai\\n\u0026#34;;    erase (borrar) Puedes borrar un valor si le entregas el iterador al valor.\n12 13 14  set \u0026lt; int \u0026gt;::iterator it = conjunto.find(11); if (it != conjunto.end()) conjunto.erase(it);    Iterar a trav√©s de un conjunto Puedes iterar a trav√©s de un conjunto con los valores ya ordenados con un iterador:\n15 16 17 18  // Imprime 10 11 20 30 40 for (it = conjunto.begin(); it != conjunto.end(); ++it) cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;    Map (mapa, tabla de hashing)  Toma dos datos, una llave y un valor. Puedes buscar una llave en tiempo logar√≠tmico con la implementaci√≥n de la STL. Pero con otras implementaciones se puede hacer en tiempo constante. Las llaves no se pueden repetir.\nEjemplo cotidiano Libros:\n   T√≠tulo (Llave) Autor (Valor)     The C Programming Language Brian Keringhan   The AWK Programming Language Brian Keringhan   1984 George Orwell    Curso:\n   Apellido Cantidad de alumnos con el apellido     Gonzalez 3   Perez 2    Inicializar Incluimos la librer√≠a de map:\n1  #include \u0026lt;map\u0026gt;   Inicializamos el mapa curso:\n2  map\u0026lt;string, int\u0026gt; curso;    Insert (insertar) Forma 1:\n3  curso[\u0026#34;perez\u0026#34;] = 1;    Forma 2:\n4  curso.insert(pair\u0026lt;string, int\u0026gt;(\u0026#34;gonzalez, 3\u0026#34;));    Operar con los valores Se puede operar con el valor tomando la llave. Ejemplo 1:\n5  ++curso.[\u0026#34;perez\u0026#34;]; // Incrementar el valor de la llave perez, por ejemplo.    Ejemplo 2:\n6  cout \u0026lt;\u0026lt; curso.[\u0026#34;perez\u0026#34;] \u0026lt;\u0026lt; endl; // El output ser√° 2.    Cuidado con operar con valores no existentes, pues los inicializar√° de una forma inesperada.\nFind (encontrar) Retorna un iterador, si no lo encuentra, apunta a map.end() Asignamos el iterador it a gonzalez, y luego lo usamos:\n7 8 9 10 11 12 13  map\u0026lt;string, int\u0026gt;::iterator it; it = curso.find(\u0026#34;gonzalez\u0026#34;); if (it != curso.end()){ cout \u0026lt;\u0026lt; \u0026#34;Hay \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; en el curso:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Llave: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; Valor: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }    Podemos incluso operar usando los iteradores:\n14  it-\u0026gt;++second;    Erase (borrar) Forma 1:\n15 16  it = curso.find(\u0026#34;perez\u0026#34;); curso.erase(it);    Forma 2:\n17  curso.erase(\u0026#34;gonzalez\u0026#34;);    Recorrer los valores de un vector Es exactamente igual que en un conjunto:\n18 19 20  for (it = curso.begin(); it != curso.end(); ++it){ cout \u0026lt;\u0026lt; \u0026#34;Llave: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; Valor: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }    Dudas que no dejan dormir    ¬øQu√© pasa si modifico una llave?\nNo se puede, tu c√≥digo no compilar√° pues es ilegal hacerlo üëÆüöìüö®\n     ¬øPuedo buscar con el second?\nNo, en ese caso recomendamos otra estructura, o tener dos maps üëÄ\n     ¬øPuedo tener un map dentro de un map?\nSi, pero es de psic√≥pata buscar dentro de ese map.\n  "});index.add({'id':5,'href':'ele38.github.io/tags/','title':"Tags",'content':""});})();