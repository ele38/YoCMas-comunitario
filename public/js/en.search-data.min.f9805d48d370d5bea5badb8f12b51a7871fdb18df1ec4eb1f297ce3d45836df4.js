'use strict';(function(){const indexCfg={};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create(indexCfg);window.geekdocSearchIndex=index;index.add({'id':0,'href':'/categories/','title':"Categories",'content':""});index.add({'id':1,'href':'/clase3/','title':"Clase 3",'content':"Vectores Los vectores son como arreglos, excepto de que el tamaño es dinámico, es decir, se puede cambiar.\nint n = 3; vector \u0026lt; int \u0026gt; vec(n); Funciones eficientes Asignar un valor a un indice vec[2] = 1; // Asigna el valor \u0026#34;1\u0026#34; al índice 2 (es decir, al 3er valor del vector) push back (empujar atrás) Si no sabemos el tamaño de nuestro vector, podemos simplemente usar push_back(valor); para enviar es valor al final del vector.\nvec.push_back(1); // Inserta un 1 al final del vector Por ejemplo, se podría usar en un for, sin necesidad de inicializar el vector con una cantidad de valores.\nvector \u0026lt;int\u0026gt; vec2; int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; ++i){ int valor; cin \u0026gt;\u0026gt; valor; vec2.push_back(); } pop back (quitar atrás) Elimina el último valor del vector.\nvec.pop_back(); // En este caso, elimina el 1 Funciones que decaen un poco insert (insertar) Podemos insertar un valor entre dos indices de un vector. El problema de esto es que mueve todos los valores que estén más adelante, lo que es lento.\nvec.insert(vec.begin() + 2, 4); // Inserta el valor 4 al índice 2 erase (borrar) Borra un dato del vector. Al igual que el insert, tiene que mover todos los datos siguientes (esta vez a la derecha).\nvec.erase(vec.begin() + 2); // Elimina el valor con índice 2, en nuestro caso, el 4 que insertamos antes. Stacks (pilas) La pila es una estructura de datos lineal al que sólo puedes acceder al último elemento que fue insertado. Imagina una pila de platos, por ejemplo.\nstack \u0026lt; int \u0026gt; pilita; push (empujar) Empuja un dato a la cima de la pila.\npilita.push(8); // Empuja un 8 a la cima de la pila. top (cima) Lee lo que hay en la cima de la pila.\npilita.top(); // Retorna el 8. pop (quitar) Remueve el dato de la cima de la pila.\npilita.pop(); // Remueve el 8. empty (vacío) Retorna 1 si la pila está vacía, de lo contrario retorna 0.\npilita.empty(); // Retorna 1 ya que nuestra pila está vacía. size (tamaño) Retorna el tamaño de nuestra pila.\npilita.size(); // Retorna 0 ya que nuestra pila no tiene datos. Queues (colas) La cola es una estructura de datos lineal al que sólo puedes acceder al primer elemento que fue insertado. Imagina una fila de una caja de un supermercado, por ejemplo.\nqueue \u0026lt; int \u0026gt; colita; push (empujar) Añade un dato al final de la cola.\ncolita.push(5); colita.push(4); colita.push(3); colita.push(2); colita.push(1); front (frente) Lee el dato que está al frente de la cola.\ncolita.front(); // Retorna 5, ya que fue lo primero que empujamos a la cola. pop (quitar) Remueve el dato que está al frente de la cola\ncolita.pop(); // Remueve el 5 colita.front(); // Retorna 4, ya que fue lo segundo que empujamos a la cola (y que ahora está primero). empty (vacío) Retorna 1 si la cola está vacía, de lo contrario retorna 0.\ncolita.empty(); // Retorna 1 ya que nuestra cola está vacía. size (tamaño) Retorna el tamaño de nuestra cola.\ncolita.size(); // Retorna 0 ya que nuestra cola no tiene datos. Sets (conjuntos) Un grupo de datos en el que ningún dato puede estar repetido.\nset \u0026lt; int \u0026gt; conjunto; insert (insertar) Inserta un dato al conjunto. Si ya está, no hace nada.\nconjunto.insert(20); // Inserta el número 20 al set find (encontrar) Busca un valor dentro del conjunto. Si está, retorna el iterador al elemento. Nota: un iterador es el objeto que apunta a dónde está nuestro valor.\ncout \u0026lt;\u0026lt; *conjunto.find(20) \u0026lt;\u0026lt; endl; // Imprime 20, ya que el * hace que lea el iterador. Si no estuviese ahí, intentaría imprimir un iterador lo que no nos hace felices. "});index.add({'id':2,'href':'/clases/clase3/','title':"Clase 3",'content':"Vectores Los vectores son como arreglos, excepto de que el tamaño es dinámico, es decir, se puede cambiar.\nint n = 3; vector \u0026lt; int \u0026gt; vec(n); Funciones eficientes Asignar un valor a un indice vec[2] = 1; // Asigna el valor \u0026#34;1\u0026#34; al índice 2 (es decir, al 3er valor del vector) push back (empujar atrás) Si no sabemos el tamaño de nuestro vector, podemos simplemente usar push_back(valor); para enviar es valor al final del vector.\nvec.push_back(1); // Inserta un 1 al final del vector Por ejemplo, se podría usar en un for, sin necesidad de inicializar el vector con una cantidad de valores.\nvector \u0026lt;int\u0026gt; vec2; int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; ++i){ int valor; cin \u0026gt;\u0026gt; valor; vec2.push_back(); } pop back (quitar atrás) Elimina el último valor del vector.\nvec.pop_back(); // En este caso, elimina el 1 Funciones que decaen un poco insert (insertar) Podemos insertar un valor entre dos indices de un vector. El problema de esto es que mueve todos los valores que estén más adelante, lo que es lento.\nvec.insert(vec.begin() + 2, 4); // Inserta el valor 4 al índice 2 erase (borrar) Borra un dato del vector. Al igual que el insert, tiene que mover todos los datos siguientes (esta vez a la derecha).\nvec.erase(vec.begin() + 2); // Elimina el valor con índice 2, en nuestro caso, el 4 que insertamos antes. Stacks (pilas) La pila es una estructura de datos lineal al que sólo puedes acceder al último elemento que fue insertado. Imagina una pila de platos, por ejemplo.\nstack \u0026lt; int \u0026gt; pilita; push (empujar) Empuja un dato a la cima de la pila.\npilita.push(8); // Empuja un 8 a la cima de la pila. top (cima) Lee lo que hay en la cima de la pila.\npilita.top(); // Retorna el 8. pop (quitar) Remueve el dato de la cima de la pila.\npilita.pop(); // Remueve el 8. empty (vacío) Retorna 1 si la pila está vacía, de lo contrario retorna 0.\npilita.empty(); // Retorna 1 ya que nuestra pila está vacía. size (tamaño) Retorna el tamaño de nuestra pila.\npilita.size(); // Retorna 0 ya que nuestra pila no tiene datos. Queues (colas) La cola es una estructura de datos lineal al que sólo puedes acceder al primer elemento que fue insertado. Imagina una fila de una caja de un supermercado, por ejemplo.\nqueue \u0026lt; int \u0026gt; colita; push (empujar) Añade un dato al final de la cola.\ncolita.push(5); colita.push(4); colita.push(3); colita.push(2); colita.push(1); front (frente) Lee el dato que está al frente de la cola.\ncolita.front(); // Retorna 5, ya que fue lo primero que empujamos a la cola. pop (quitar) Remueve el dato que está al frente de la cola\ncolita.pop(); // Remueve el 5 colita.front(); // Retorna 4, ya que fue lo segundo que empujamos a la cola (y que ahora está primero). empty (vacío) Retorna 1 si la cola está vacía, de lo contrario retorna 0.\ncolita.empty(); // Retorna 1 ya que nuestra cola está vacía. size (tamaño) Retorna el tamaño de nuestra cola.\ncolita.size(); // Retorna 0 ya que nuestra cola no tiene datos. Sets (conjuntos) Un grupo de datos en el que ningún dato puede estar repetido.\nset \u0026lt; int \u0026gt; conjunto; insert (insertar) Inserta un dato al conjunto. Si ya está, no hace nada.\nconjunto.insert(20); // Inserta el número 20 al set find (encontrar) Busca un valor dentro del conjunto. Si está, retorna el iterador al elemento. Nota: un iterador es el objeto que apunta a dónde está nuestro valor.\ncout \u0026lt;\u0026lt; *conjunto.find(20) \u0026lt;\u0026lt; endl; // Imprime 20, ya que el * hace que lea el iterador. Si no estuviese ahí, intentaría imprimir un iterador lo que no nos hace felices. "});index.add({'id':3,'href':'/clases/','title':"Clases",'content':""});index.add({'id':4,'href':'/tags/','title':"Tags",'content':""});index.add({'id':5,'href':'/','title':"YoC+",'content':""});})();