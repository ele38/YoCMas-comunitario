'use strict';(function(){const indexCfg={};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create(indexCfg);window.geekdocSearchIndex=index;index.add({'id':0,'href':'yoc+/','title':"Estructuras lineales",'content':" Table of Contents  Vectores Stacks (pilas) Queues (colas)     Vectores Stacks (Pilas)  Vectores Los vectores son como arreglos, excepto de que el tamaño es dinámico, es decir, se puede cambiar. Incluimos la librería:\n1  #include \u0026lt;vector\u0026gt;   Inicializamos nuestro vector \u0026ldquo;vec\u0026rdquo;:\n2 3  int n = 3; vector \u0026lt; int \u0026gt; vec(n, 0); // Inicializa un vector de tamaño 3 con todos sus valores = 0. Tanto el tamaño como valor son opcionales.    Asignar un valor 4  vec[2] = 1; // Asigna el valor \u0026#34;1\u0026#34; al índice 2 (es decir, al 3er valor del vector)    push back (empujar atrás) Si no sabemos el tamaño de nuestro vector, podemos simplemente usar push_back(valor); para enviar es valor al final del vector.\n5  vec.push_back(1); // Inserta un 1 al final del vector    Por ejemplo, se podría usar en un for, sin necesidad de inicializar el vector con una cantidad de valores.\n6 7 8 9 10 11 12 13  vector \u0026lt;int\u0026gt; vec2; int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; ++i){ int valor; cin \u0026gt;\u0026gt; valor; vec2.push_back(); }    pop back (quitar atrás) Elimina el último valor del vector.\n14  vec.pop_back(); // En este caso, elimina el 1    insert (insertar) Podemos insertar un valor entre dos indices de un vector. El problema de esto es que mueve todos los valores que estén más adelante, lo que es lento.\n15  vec.insert(vec.begin() + 2, 4); // Inserta el valor 4 al índice 2    erase (borrar) Borra un dato del vector. Al igual que el insert, tiene que mover todos los datos siguientes (esta vez a la derecha).\n16  vec.erase(vec.begin() + 2); // Elimina el valor con índice 2, en nuestro caso, el 4 que insertamos antes.    Stacks (pilas) La pila es una estructura de datos lineal al que sólo puedes acceder al último elemento que fue insertado. Imagina una pila de platos, por ejemplo.\n1  stack \u0026lt; int \u0026gt; pilita;    push (empujar) Empuja un dato a la cima de la pila.\n2  pilita.push(8); // Empuja un 8 a la cima de la pila.    top (cima) Lee lo que hay en la cima de la pila.\n3  pilita.top(); // Retorna el 8.    pop (quitar) Remueve el dato de la cima de la pila.\n4  pilita.pop(); // Remueve el 8.    empty (vacío) Retorna 1 si la pila está vacía, de lo contrario retorna 0.\n5  pilita.empty(); // Retorna 1 ya que nuestra pila está vacía.    size (tamaño) Retorna el tamaño de nuestra pila.\n6  pilita.size(); // Retorna 0 ya que nuestra pila no tiene datos.    Queues (colas)  La cola es una estructura de datos lineal al que sólo puedes acceder al primer elemento que fue insertado. Imagina una fila de una caja de un supermercado, por ejemplo.\n1  queue \u0026lt; int \u0026gt; colita;    push (empujar) Añade un dato al final de la cola.\n2 3 4 5 6  colita.push(5); colita.push(4); colita.push(3); colita.push(2); colita.push(1);    front (frente) Lee el dato que está al frente de la cola.\n7  colita.front(); // Retorna 5, ya que fue lo primero que empujamos a la cola.    pop (quitar) Remueve el dato que está al frente de la cola\n8 9  colita.pop(); // Remueve el 5 colita.front(); // Retorna 4, ya que fue lo segundo que empujamos a la cola (y que ahora está primero).    empty (vacío) Retorna 1 si la cola está vacía, de lo contrario retorna 0.\n10  colita.empty(); // Retorna 1 ya que nuestra cola está vacía.    size (tamaño) Retorna el tamaño de nuestra cola.\n11  colita.size(); // Retorna 0 ya que nuestra cola no tiene datos.    "});index.add({'id':1,'href':'yoc+/estructuras_arbol/','title':"Estructuras en forma de árbol",'content':" Table of Contents  Set (conjunto) Map (mapa, tabla de hashing)    Véase: arbol binario\nSet (conjunto)  No permite que hayan elementos repetidos.\nInicialización Incluimos la librería:\n1  #include \u0026lt;set\u0026gt;   Inicializamos nuestro conjunto:\n2  set \u0026lt; int \u0026gt; conjunto; // int puede ser reemplazado con cualquier otro tipo de dato    insert (Insertar) Inserta un dato. Retorna un par de elementos, el primero siendo el iterador del valor insertado y el segundo siendo un bool que marca si es que ya existía o no. En el ejemplo de abajo, usamos .second para comprobar si se insertó correctamente o no.\n3 4 5 6 7 8 9  if (conjunto.insert(10).second) // Retorna TRUE ya que no estaba anteriormente  cout \u0026lt;\u0026lt; \u0026#34;ganai\\n\u0026#34;; if (conjunto.insert(10).second); // Retorna FALSE ya que ya había un 10. cout \u0026lt;\u0026lt; \u0026#34;no ganai\\n\u0026#34;; conjunto.insert(20); conjunto.insert(40); conjunto.insert(30); conjunto.insert(11);    find (Encontrar) Busca un elemento en el set y si lo encuentra retorna un iterador al valor. De lo contrario, retorna conjunto.end();\n10 11  if (conjunto.find(10) != conjunto.end()) cout \u0026lt;\u0026lt; \u0026#34;ganai\\n\u0026#34;;    erase (borrar) Puedes borrar un valor si le entregas el iterador al valor.\n12 13 14  set \u0026lt; int \u0026gt;::iterator it = conjunto.find(11); if (it != conjunto.end()) conjunto.erase(it);    Iterar a través de un conjunto Puedes iterar a través de un conjunto con los valores ya ordenados con un iterador:\n15 16 17 18  // Imprime 10 11 20 30 40 for (it = conjunto.begin(); it != conjunto.end(); ++it) cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;    Map (mapa, tabla de hashing)  Toma dos datos, una llave y un valor. Puedes buscar una llave en tiempo logarítmico con la implementación de la STL. Pero con otras implementaciones se puede hacer en tiempo constante. Las llaves no se pueden repetir.\nEjemplo cotidiano Libros:\n   Título (Llave) Autor (Valor)     The C Programming Language Brian Keringhan   The AWK Programming Language Brian Keringhan   1984 George Orwell    Curso:\n   Apellido Cantidad de alumnos con el apellido     Gonzalez 3   Perez 2    Inicializar Incluimos la librería de map:\n1  #include \u0026lt;map\u0026gt;   Inicializamos el mapa curso:\n2  map\u0026lt;string, int\u0026gt; curso;    Insert (insertar) Forma 1:\n3  curso[\u0026#34;perez\u0026#34;] = 1;    Forma 2:\n4  curso.insert(pair\u0026lt;string, int\u0026gt;(\u0026#34;gonzalez, 3\u0026#34;));    Operar con los valores Se puede operar con el valor tomando la llave. Ejemplo 1:\n5  ++curso.[\u0026#34;perez\u0026#34;]; // Incrementar el valor de la llave perez, por ejemplo.    Ejemplo 2:\n6  cout \u0026lt;\u0026lt; curso.[\u0026#34;perez\u0026#34;] \u0026lt;\u0026lt; endl; // El output será 2.    Cuidado con operar con valores no existentes, pues los inicializará de una forma inesperada.\nFind (encontrar) Retorna un iterador, si no lo encuentra, apunta a map.end() Asignamos el iterador it a gonzalez, y luego lo usamos:\n7 8 9 10 11 12 13  map\u0026lt;string, int\u0026gt;::iterator it; it = curso.find(\u0026#34;gonzalez\u0026#34;); if (it != curso.end()){ cout \u0026lt;\u0026lt; \u0026#34;Hay \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; en el curso:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Llave: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; Valor: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }    Podemos incluso operar usando los iteradores:\n14  it-\u0026gt;++second;    Erase (borrar) Forma 1:\n15 16  it = curso.find(\u0026#34;perez\u0026#34;); curso.erase(it);    Forma 2:\n17  curso.erase(\u0026#34;gonzalez\u0026#34;);    Recorrer los valores de un mapa Es exactamente igual que en un conjunto:\n18 19 20  for (it = curso.begin(); it != curso.end(); ++it){ cout \u0026lt;\u0026lt; \u0026#34;Llave: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; Valor: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }    Dudas que no dejan dormir ¿Qué pasa si modifico una llave? No se puede, tu código no compilará pues es ilegal hacerlo 👮🚓🚨\n¿Puedo buscar con el second? No, en ese caso recomendamos otra estructura, o tener dos maps 👀\n¿Puedo tener un map dentro de un map? Si, pero es de psicópata buscar dentro de ese map.\n"});index.add({'id':2,'href':'yoc+/vectores/','title':"Vectores",'content':" Table of Contents  Asignar un valor push back (empujar atrás) pop back (quitar atrás) insert (insertar) erase (borrar)    Los vectores son como arreglos, excepto de que el tamaño es dinámico, es decir, se puede cambiar. Incluimos la librería:\n1  #include \u0026lt;vector\u0026gt;   Inicializamos nuestro vector \u0026ldquo;vec\u0026rdquo;:\n2 3  int n = 3; vector \u0026lt; int \u0026gt; vec(n, 0); // Inicializa un vector de tamaño 3 con todos sus valores = 0. Tanto el tamaño como valor son opcionales.    Asignar un valor 4  vec[2] = 1; // Asigna el valor \u0026#34;1\u0026#34; al índice 2 (es decir, al 3er valor del vector)    push back (empujar atrás) Si no sabemos el tamaño de nuestro vector, podemos simplemente usar push_back(valor); para enviar es valor al final del vector.\n5  vec.push_back(1); // Inserta un 1 al final del vector    Por ejemplo, se podría usar en un for, sin necesidad de inicializar el vector con una cantidad de valores.\n6 7 8 9 10 11 12 13  vector \u0026lt;int\u0026gt; vec2; int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; ++i){ int valor; cin \u0026gt;\u0026gt; valor; vec2.push_back(); }    pop back (quitar atrás) Elimina el último valor del vector.\n14  vec.pop_back(); // En este caso, elimina el 1    insert (insertar) Podemos insertar un valor entre dos indices de un vector. El problema de esto es que mueve todos los valores que estén más adelante, lo que es lento.\n15  vec.insert(vec.begin() + 2, 4); // Inserta el valor 4 al índice 2    erase (borrar) Borra un dato del vector. Al igual que el insert, tiene que mover todos los datos siguientes (esta vez a la derecha).\n16  vec.erase(vec.begin() + 2); // Elimina el valor con índice 2, en nuestro caso, el 4 que insertamos antes.    "});index.add({'id':3,'href':'yoc+/stacks/','title':"Stacks (pilas)",'content':" Table of Contents  push (empujar) top (cima) pop (quitar) empty (vacío) size (tamaño)    La pila es una estructura de datos lineal al que sólo puedes acceder al último elemento que fue insertado. Imagina una pila de platos, por ejemplo.\n1  stack \u0026lt; int \u0026gt; pilita;    push (empujar) Empuja un dato a la cima de la pila.\n2  pilita.push(8); // Empuja un 8 a la cima de la pila.    top (cima) Lee lo que hay en la cima de la pila.\n3  pilita.top(); // Retorna el 8.    pop (quitar) Remueve el dato de la cima de la pila.\n4  pilita.pop(); // Remueve el 8.    empty (vacío) Retorna 1 si la pila está vacía, de lo contrario retorna 0.\n5  pilita.empty(); // Retorna 1 ya que nuestra pila está vacía.    size (tamaño) Retorna el tamaño de nuestra pila.\n6  pilita.size(); // Retorna 0 ya que nuestra pila no tiene datos.    "});index.add({'id':4,'href':'yoc+/categories/','title':"Categories",'content':""});index.add({'id':5,'href':'yoc+/categories/EDD/','title':"EDD",'content':""});index.add({'id':6,'href':'yoc+/tags/','title':"Tags",'content':""});})();